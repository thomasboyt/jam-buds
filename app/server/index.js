const express = require('express');
const cookieParser = require('cookie-parser');
const proxy = require('http-proxy-middleware');
const { createBundleRenderer } = require('vue-server-renderer');
const axios = require('axios');
const setupDevServer = require('./devServer');
const Raven = require('raven');

const AUTH_TOKEN_COOKIE = 'jamBudsAuthToken';

const app = express();

const isProd = process.env.NODE_ENV === 'production';

if (isProd) {
  Raven.config(process.env.SENTRY_DSN_APP).install();
  app.use(Raven.requestHandler());
}

const template = `
  <html>
    <head>
      <title>{{title}}</title>
      <script src="https://www.youtube.com/iframe_api"></script>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel="icon" href="/favicon16.png" type="image/png" sizes="32x32">
      <link rel="icon" href="/favicon32.png" type="image/png" sizes="32x32">
    </head>
    <body>
      <div id="app">
        <!--vue-ssr-outlet-->
      </div>
      {{{spriteContent}}}
    </body>
  </html>
`;

function createRenderer(bundle, clientManifest) {
  return createBundleRenderer(bundle, {
    // recommended for performance
    runInNewContext: false,
    clientManifest,
    template,
  });
}

async function main() {
  let renderer;
  let readyPromise;
  let buildErrors;

  if (isProd) {
    // In production: create server renderer using template and built server bundle.
    // The server bundle is generated by vue-ssr-webpack-plugin.
    const serverBundle = require('../build/vue-ssr-server-bundle.json');

    // The client manifests are optional, but it allows the renderer
    // to automatically infer preload/prefetch links and directly add <script>
    // tags for any async chunks used during render, avoiding waterfall requests.
    const resp = await axios.get(
      `${process.env.STATIC_URL}/vue-ssr-client-manifest.json`
    );
    const clientManifest = resp.data;

    renderer = createRenderer(serverBundle, clientManifest);
  } else {
    // In development: setup the dev server with watch and hot-reload,
    // and create a new renderer on bundle / index template update.
    setupDevServer(app, {
      onStart: (promise) => {
        readyPromise = promise;
        buildErrors = null;
      },
      onComplete: (bundle, clientManifest) => {
        renderer = createRenderer(bundle, clientManifest);
      },
      onError: (errors) => {
        buildErrors = errors;
      },
    });
  }

  function renderWebpackError(req, res, buildErrors) {
    res.send(`
      <html>
        <body>
          <h3>webpack build failed :(</h3>
          <pre>${buildErrors}</pre>
        </body>
      </html>
    `);
  }

  function renderAppError(req, res, err) {
    if (err.url) {
      res.redirect(err.url);
    } else if (err.code === 404) {
      // not sure this ever gets triggered cuz there's a wildcard route
      res.status(404).send('404 | Page Not Found');
    } else {
      // Render Error Page or Redirect
      res.status(500);

      if (!isProd) {
        res.send(`
          <html>
            <body>
              <h3>encountered an error :(</h3>
              <pre>${err.stack}</pre>
            </body>
          </html>
        `);
      } else {
        res.send('500 | Internal Server Error');
      }

      console.error(`error during render : ${req.url}`);
      console.error(err.stack);
    }
  }

  function render(req, res) {
    const authToken = req.cookies[AUTH_TOKEN_COOKIE];

    const context = {
      url: req.url,
      authToken,
      title: 'Jam Buds',
    };

    renderer.renderToString(context, (err, html) => {
      if (err) {
        return renderAppError(req, res, err);
      }
      res.send(html);
    });
  }

  const port = process.env.PORT || 8080;

  app.use(cookieParser());

  app.use(
    '/auth',
    proxy({
      target: process.env.API_URL,
      changeOrigin: true,
      cookieDomainRewrite: process.env.APP_URL,
    })
  );

  app.get('*', (req, res) => {
    if (isProd) {
      return render(req, res);
    } else {
      if (buildErrors) {
        renderWebpackError(req, res, buildErrors);
      } else {
        readyPromise.then(() => render(req, res));
      }
    }
  });

  if (isProd) {
    app.use(Raven.errorHandler());
  }

  app.listen(port, () => {
    console.log(`server started on port ${port}`);
  });
}

main();
