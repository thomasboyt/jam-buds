const express = require('express');
const cookieParser = require('cookie-parser');
const proxy = require('http-proxy-middleware');
const { createBundleRenderer } = require('vue-server-renderer');
const axios = require('axios');
const setupDevServer = require('./devServer');
const Raven = require('raven');
const { renderTemplate, templates } = require('./templates');

const AUTH_TOKEN_COOKIE = 'jamBudsAuthToken';

const app = express();

const isProd = process.env.NODE_ENV === 'production';

if (isProd) {
  Raven.config(process.env.SENTRY_DSN_APP).install();
  app.use(Raven.requestHandler());
}

function createRenderer(bundle, clientManifest) {
  return createBundleRenderer(bundle, {
    // recommended for performance
    runInNewContext: false,
    clientManifest,
    template: templates['index'],
  });
}

async function main() {
  let renderer;
  let readyPromise;
  let buildErrors;

  if (isProd) {
    // In production: create server renderer using template and built server bundle.
    // The server bundle is generated by vue-ssr-webpack-plugin.
    const serverBundle = require('../build/vue-ssr-server-bundle.json');

    // The client manifests are optional, but it allows the renderer
    // to automatically infer preload/prefetch links and directly add <script>
    // tags for any async chunks used during render, avoiding waterfall requests.
    const clientManifest = (await axios.get(
      `${process.env.STATIC_URL}/vue-ssr-client-manifest.json`
    )).data;

    renderer = createRenderer(serverBundle, clientManifest);
  } else {
    // In development: setup the dev server with watch and hot-reload,
    // and create a new renderer on bundle / index template update.
    setupDevServer(app, {
      onStart: (promise) => {
        readyPromise = promise;
        buildErrors = null;
      },
      onComplete: (bundle, clientManifest) => {
        renderer = createRenderer(bundle, clientManifest);
      },
      onError: (errors) => {
        buildErrors = errors;
      },
    });
  }

  function renderWebpackError(req, res, buildErrors) {
    res.send(renderTemplate('webpackError'));
  }

  function renderAppError(req, res, err, context) {
    if (err.url) {
      res.redirect(err.url);
    } else if (
      err.code === 404 ||
      (err.response && err.response.status === 404)
    ) {
      res.status(404);

      res.send(renderTemplate('404'));
    } else {
      // Render Error Page or Redirect
      res.status(500);

      if (!isProd) {
        res.send(renderTemplate('500-dev', { stack: err.stack }));
      } else {
        res.send(renderTemplate('500'));
      }

      console.error(`error during render : ${req.url}`);
      console.error(err.stack);
    }
  }

  function render(req, res) {
    const authToken = req.cookies[AUTH_TOKEN_COOKIE];

    const context = {
      url: req.url,
      authToken,
      title: 'Jam Buds',
      staticUrl: process.env.STATIC_URL,
    };

    renderer.renderToString(context, (err, html) => {
      if (err) {
        return renderAppError(req, res, err, context);
      }
      res.send(html);
    });
  }

  const port = process.env.PORT || 8080;

  app.use(cookieParser());

  app.use(
    '/auth',
    proxy({
      target: process.env.API_URL,
      changeOrigin: true,
      cookieDomainRewrite: process.env.APP_URL,
    })
  );

  app.get('*', (req, res) => {
    if (isProd) {
      return render(req, res);
    } else {
      if (buildErrors) {
        renderWebpackError(req, res, buildErrors);
      } else {
        readyPromise.then(() => render(req, res));
      }
    }
  });

  if (isProd) {
    app.use(Raven.errorHandler());
  }

  app.listen(port, () => {
    console.log(`server started on port ${port}`);
  });
}

main();
