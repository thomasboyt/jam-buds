const express = require('express');
const cookieParser = require('cookie-parser');
const proxy = require('http-proxy-middleware');
const {createBundleRenderer} = require('vue-server-renderer');
const axios = require('axios');
const setupDevServer = require('./devServer');

const AUTH_TOKEN_COOKIE = 'jamBudsAuthToken';

const app = express();

const isProd = process.env.NODE_ENV === 'production';

const template = `
  <html>
    <head>
      <title>app</title>
      <script src="https://www.youtube.com/iframe_api"></script>
      <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
      <div id="app">
        <!--vue-ssr-outlet-->
      </div>
    </body>
  </html>
`;

function createRenderer(bundle, clientManifest) {
  return createBundleRenderer(bundle,  {
    // recommended for performance
    runInNewContext: false,
    clientManifest,
    template,
  });
}

async function main() {
  let renderer;
  let readyPromise;

  if (isProd) {
    // In production: create server renderer using template and built server bundle.
    // The server bundle is generated by vue-ssr-webpack-plugin.
    const serverBundle = require('../build/vue-ssr-server-bundle.json');

    // The client manifests are optional, but it allows the renderer
    // to automatically infer preload/prefetch links and directly add <script>
    // tags for any async chunks used during render, avoiding waterfall requests.
    const resp = await axios.get(`${process.env.STATIC_URL}/vue-ssr-client-manifest.json`);
    const clientManifest = resp.data;

    renderer = createRenderer(serverBundle, clientManifest);

  } else {
    // In development: setup the dev server with watch and hot-reload,
    // and create a new renderer on bundle / index template update.
    readyPromise = setupDevServer(app, (bundle, clientManifest) => {
      renderer = createRenderer(bundle, clientManifest)
    });
  }

  function render(req, res) {
    const handleError = (err) => {
      if (err.url) {
        res.redirect(err.url)
      } else if(err.code === 404) {
        // not sure this ever gets triggered cuz there's a wildcard route
        res.status(404).send('404 | Page Not Found')
      } else {
        // Render Error Page or Redirect
        res.status(500);

        if (!isProd) {
          res.send(`
            <html>
              <body>
                <h3>encountered an error :(</h3>
                <pre>${err.stack}</pre>
              </body>
            </html>
          `);
        } else {
          res.send('500 | Internal Server Error')
        }

        console.error(`error during render : ${req.url}`)
        console.error(err.stack)
      }
    }

    const authToken = req.cookies[AUTH_TOKEN_COOKIE];

    const context = {
      url: req.url,
      authToken,
    };

    renderer.renderToString(context, (err, html) => {
      if (err) {
        return handleError(err);
      }
      res.send(html);
    });
  }

  const port = process.env.PORT || 8080;

  app.use(cookieParser());

  app.use('/auth', proxy({
    target: process.env.API_URL,
    changeOrigin: true,
    cookieDomainRewrite: process.env.APP_URL,
  }));

  app.get('*', (req, res) => {
    if (isProd) {
      return render(req, res);
    } else {
      readyPromise.then(() => render(req, res));
    }
  });

  app.listen(port, () => {
    console.log(`server started on port ${port}`);
  });
}

main();